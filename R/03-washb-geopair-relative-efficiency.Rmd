---
title: "Geographic pair matching in large-scale cluster randomized trials"
subtitle: "Estimates of relative efficiency"
author: "Ben Arnold ben.arnold@ucsf.edu"
date: "updated: `r Sys.time()`"
output: 
  html_document:
    theme: default
    highlight: pygments
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: true
      smooth_scroll: true
---

# Summary

Summary here: **TBD**

Relative efficacy based on non-parametric estimator from Imai, King, and Nall (2009)

Details of original citations and data sources here: **TBD**


# Preamble

```{r preamble}
library(here)
here()
#----------------------------
# source the config file
#----------------------------
source(here("R","washb-geopair-Config.R"))

#----------------------------
# source the base functions
#----------------------------
source(here("R","washb-geopair-Functions.R"))

```



# Bangladesh

## Data prep

```{r load bangladesh data}
#-------------------------------
# load the formatted analysis
# data created by
# washb-geopair-data-processing.R
#-------------------------------

# anthropometry data
danth <- read_rds(here("data","bangl_analysis_anthro.rds")) %>%
  filter(tr %in% c("Control","Nutrition","Nutrition + WSH")) %>%
  mutate(tr01 = ifelse(tr=="Control",0,1)) 
  

# child development data
dchdev <- read_rds(here("data","bangl_analysis_chdev.rds")) %>%
  filter(tr %in% c("Control","Nutrition","Nutrition + WSH")) %>%
  mutate(tr01 = ifelse(tr=="Control",0,1))

# diarrhea data
ddiar <- read_rds(here("data","bangl_analysis_diar.rds")) %>%
  filter(tr %in% c("Control","Nutrition","Nutrition + WSH")) %>%
  mutate(tr01 = ifelse(tr=="Control",0,1))

# giardia data
dpara <- read_rds(here("data","bangl_analysis_parasite.rds")) %>%
  filter(tr %in% c("Control","Nutrition","Nutrition + WSH")) %>%
  mutate(tr01 = ifelse(tr=="Control",0,1))

```

## Estimate ATE and relative efficacy
```{r estimate ATE and relative efficiency bangladesh}
#-------------------------------
# the estimate_Imai_ATE function
# does not allow for missing values
# in the outcome, so subset each
# dataset to non-missing values
# before each estimation
#
# the estimate_IMAI_ATE function
# is in washb-geopair-Functions.R
#-------------------------------

#-------------------------------
# LAZ
#-------------------------------
d <- danth %>% filter(!is.na(laz))
ate_laz <- estimate_Imai_ATE(Y=d$laz,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# WAZ
#-------------------------------
d <- danth %>% filter(!is.na(waz))
ate_waz <- estimate_Imai_ATE(Y=d$waz,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# WHZ
#-------------------------------
d <- danth %>% filter(!is.na(whz))
ate_whz <- estimate_Imai_ATE(Y=d$whz,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# HCZ
#-------------------------------
d <- danth %>% filter(!is.na(hcz))
ate_hcz <- estimate_Imai_ATE(Y=d$hcz,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# EASQ Communication
#-------------------------------
d <- dchdev %>% filter(!is.na(z_easq_com))
ate_easq_com <- estimate_Imai_ATE(Y=d$z_easq_com,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# EASQ Gross motor
#-------------------------------
d <- dchdev %>% filter(!is.na(z_easq_motor))
ate_easq_mot <- estimate_Imai_ATE(Y=d$z_easq_motor,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# EASQ Personal-social
#-------------------------------
d <- dchdev %>% filter(!is.na(z_easq_pers))
ate_easq_ps <- estimate_Imai_ATE(Y=d$z_easq_pers,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# CDI comprehension
#-------------------------------
d <- dchdev %>% filter(!is.na(z_cdi_comp))
ate_cdi_comp <- estimate_Imai_ATE(Y=d$z_cdi_comp,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# CDI expression
#-------------------------------
d <- dchdev %>% filter(!is.na(z_cdi_expr))
ate_cdi_expr <- estimate_Imai_ATE(Y=d$z_cdi_expr,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# Diarrhea
#-------------------------------
d <- ddiar %>% filter(!is.na(diar7d))
ate_diar <- estimate_Imai_ATE(Y=d$diar7d,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# Giardia
#-------------------------------
d <- dpara %>% filter(!is.na(giar))
ate_giar <- estimate_Imai_ATE(Y=d$giar,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# Ascaris
#-------------------------------
d <- dpara %>% filter(!is.na(al))
ate_al <- estimate_Imai_ATE(Y=d$al,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# Trichuris
#-------------------------------
d <- dpara %>% filter(!is.na(tt))
ate_tt <- estimate_Imai_ATE(Y=d$tt,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# Hookworm
#-------------------------------
d <- dpara %>% filter(!is.na(hw))
ate_hw <- estimate_Imai_ATE(Y=d$hw,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

```


```{r summarize relative efficiency bangladesh}
#-------------------------------
# Summarize relative efficacy
#-------------------------------
ate_list <- list(ate_laz,ate_waz,ate_whz,ate_hcz,
                 ate_easq_com,ate_easq_mot,ate_easq_ps,ate_cdi_comp,ate_cdi_expr,
                 ate_diar,ate_giar,ate_al,ate_tt,ate_hw)
out_list <- c("length-for-age z",
                         "weight-for-age z",
                         "weight-for-height z",
                         "head circumference z",
                         "EASQ communication z",
                         "EASQ gross motor z",
                         "EASQ personal-social z",
                         "CDI comprehension z",
                         "CDI expression z",
                         "Diarrhea",
                         "Giardia sp.",
                         "Ascaris sp.",
                         "Trichuris sp.",
                         "Hookworm")

ate_res <- foreach(esti = 1:length(ate_list), .combine = rbind) %do% {
  res <- data.frame(est = ate_list[[esti]]$est, var = ate_list[[esti]]$var,
                    est_min95 = ate_list[[esti]]$est_min95, est_max95 = ate_list[[esti]]$est_max95,
                    corr_w = ate_list[[esti]]$corr_w, corr_u = ate_list[[esti]]$corr_u,
                    eff_w = ate_list[[esti]]$eff_w, eff_u = ate_list[[esti]]$eff_u)
  res
}
ate_res$outcome_lab <- out_list
ate_res <- ate_res %>%
  mutate(outcome_lab = factor(outcome_lab, levels = out_list),
         country = "Bangladesh") %>%
  dplyr::select(country,outcome_lab, everything())

```


# Kenya

## Data prep

```{r load Kenya data}
#-------------------------------
# load the formatted analysis
# data created by
# washb-geopair-data-processing.R
#
# in each dataset, exclude 
# the 10 matched blocks that do
# not have treatment contrasts
# for nutrition vs. control
#-------------------------------

# anthropometry data
dkanth <- read_rds(here("data","kenya_analysis_anthro.rds")) %>%
  filter(tr %in% c("Control","Nutrition","Nutrition + WSH")) %>%
  mutate(tr01 = ifelse(tr %in% c("Control","Passive Control"),0,1)) %>%
  filter(!block %in% c(11,13,20,23,33,40,65,72,84,85))


# diarrhea data
dkdiar <- read_rds(here("data","kenya_analysis_diar.rds")) %>%
  filter(tr %in% c("Control","Nutrition","Nutrition + WSH")) %>%
  mutate(tr01 = ifelse(tr %in% c("Control"),0,1)) %>%
  filter(!block %in% c(11,13,20,23,33,40,65,72,84,85))

# parasite data
dkpara <- read_rds(here("data","kenya_analysis_parasite.rds")) %>%
  filter(tr %in% c("Control","Nutrition","Nutrition + WSH")) %>%
  mutate(tr01 = ifelse(tr %in% c("Control"),0,1)) %>%
  filter(!block %in% c(11,13,20,23,33,40,65,72,84,85))

# child development data
dkchdev <- read_rds(here("data","kenya_analysis_chdev.rds")) %>%
  filter(tr %in% c("Control","Nutrition","Nutrition + WSH")) %>%
  mutate(tr01 = ifelse(tr %in% c("Control"),0,1)) %>%
  filter(!block %in% c(11,13,20,23,33,40,65,72,84,85))

```

## Estimate ATE and relative efficiency
```{r estimate ATE and relative efficiency kenya}
#-------------------------------
# the estimate_Imai_ATE function
# does not allow for missing values
# in the outcome, so subset each
# dataset to non-missing values
# before each estimation
#-------------------------------

#-------------------------------
# LAZ
#-------------------------------
d <- dkanth %>% filter(!is.na(laz)) 
k_ate_laz <- estimate_Imai_ATE(Y=d$laz,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# WAZ
#-------------------------------
d <- dkanth %>% filter(!is.na(waz)) 
k_ate_waz <- estimate_Imai_ATE(Y=d$waz,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# WHZ
#-------------------------------
d <- dkanth %>% filter(!is.na(whz))
k_ate_whz <- estimate_Imai_ATE(Y=d$whz,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# HCZ
#-------------------------------
d <- dkanth %>% filter(!is.na(hcz))
k_ate_hcz <- estimate_Imai_ATE(Y=d$hcz,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# EASQ Communication
#-------------------------------
d <- dkchdev %>% filter(!is.na(z_easq_com))
k_ate_easq_com <- estimate_Imai_ATE(Y=d$z_easq_com,Z=d$tr01,grp=d$clusteridr2,match=d$block,data=d)

#-------------------------------
# EASQ Gross motor
#-------------------------------
d <- dkchdev %>% filter(!is.na(z_easq_motor))
k_ate_easq_mot <- estimate_Imai_ATE(Y=d$z_easq_motor,Z=d$tr01,grp=d$clusteridr2,match=d$block,data=d)

#-------------------------------
# EASQ Personal-social
#-------------------------------
d <- dkchdev %>% filter(!is.na(z_easq_pers))
k_ate_easq_ps <- estimate_Imai_ATE(Y=d$z_easq_pers,Z=d$tr01,grp=d$clusteridr2,match=d$block,data=d)


#-------------------------------
# Diarrhea
#-------------------------------
d <- dkdiar %>% filter(!is.na(diar7d))
k_ate_diar <- estimate_Imai_ATE(Y=d$diar7d,Z=d$tr01,grp=d$clusterid,match=d$block,data=d)

#-------------------------------
# Giardia
#-------------------------------
d <- dkpara %>% filter(!is.na(giar))
k_ate_giar <- estimate_Imai_ATE(Y=d$giar,Z=d$tr01,grp=d$clusteridr2,match=d$block,data=d)

#-------------------------------
# Ascaris
#-------------------------------
d <- dkpara %>% filter(!is.na(al))
k_ate_al <- estimate_Imai_ATE(Y=d$al,Z=d$tr01,grp=d$clusteridr2,match=d$block,data=d)

#-------------------------------
# Trichuris
#-------------------------------
d <- dkpara %>% filter(!is.na(tt))
k_ate_tt <- estimate_Imai_ATE(Y=d$tt,Z=d$tr01,grp=d$clusteridr2,match=d$block,data=d)

#-------------------------------
# Hookworm
#-------------------------------
d <- dkpara %>% filter(!is.na(hw))
k_ate_hw <- estimate_Imai_ATE(Y=d$hw,Z=d$tr01,grp=d$clusteridr2,match=d$block,data=d)

#-------------------------------
# detach experiment package
# because it uses MASS, which
# conflicts with dplyr::select()
#-------------------------------
detach("package:experiment", unload = TRUE)
detach("package:MASS", unload = TRUE)

```


```{r summarize relative efficiency kenya}
#-------------------------------
# Summarize relative efficiency
#-------------------------------
k_ate_list <- list(k_ate_laz,k_ate_waz,k_ate_whz,k_ate_hcz,
                 k_ate_easq_com,k_ate_easq_mot,k_ate_easq_ps,
                 k_ate_diar,k_ate_giar,k_ate_al,k_ate_tt,k_ate_hw)
k_out_list <- c("length-for-age z",
                         "weight-for-age z",
                         "weight-for-height z",
                         "head circumference z",
                         "EASQ communication z",
                         "EASQ gross motor z",
                         "EASQ personal-social z",
                         "Diarrhea",
                         "Giardia sp.",
                         "Ascaris sp.",
                         "Trichuris sp.",
                         "Hookworm")

k_ate_res <- foreach(esti = 1:length(k_ate_list), .combine = rbind) %do% {
  res <- data.frame(est = k_ate_list[[esti]]$est, var = k_ate_list[[esti]]$var,
                    est_min95 = k_ate_list[[esti]]$est_min95, est_max95 = k_ate_list[[esti]]$est_max95,
                    corr_w = k_ate_list[[esti]]$corr_w, corr_u = k_ate_list[[esti]]$corr_u,
                    eff_w = k_ate_list[[esti]]$eff_w, eff_u = k_ate_list[[esti]]$eff_u)
  res
}
k_ate_res$outcome_lab <- k_out_list
k_ate_res <- k_ate_res %>%
  mutate(outcome_lab = factor(outcome_lab, levels = out_list),
         country = "Kenya") %>%
  dplyr::select(country,outcome_lab, everything())

```
# Save pair-level summary dataset

Save a dataset that includes pair-level means and treatment effects. These estimates will be used in later analysis and plotting

```{r assemble pair level data}
#-------------------------------
# get the pair-level estimates
# Bangladesh
#-------------------------------
dcl_b <- foreach(i = 1:length(ate_list), .combine = rbind) %do% {
  dcli <- ate_list[[i]]$dcl
  dcli$block <- row.names(dcli)
  dcli$outcome_lab <- out_list[i]
  dcli$country = "Bangladesh"
  dcli
}
#-------------------------------
# get the pair-level estimates
# Kenya
#-------------------------------
dcl_k <- foreach(i = 1:length(k_ate_list), .combine = rbind) %do% {
  dcli <- k_ate_list[[i]]$dcl
  dcli$block <- row.names(dcli)
  dcli$outcome_lab <- k_out_list[i]
  dcli$country = "Kenya"
  dcli
}

#-------------------------------
# stack the data and convert
# some of the variables to 
# factors
#-------------------------------
dcl <- bind_rows(dcl_b,dcl_k) %>%
  mutate(outcome_lab=factor(outcome_lab, levels= out_list),
         country = factor(country)) %>%
  select(country,outcome_lab,block,everything()) %>%
  arrange(country,outcome_lab,block)

write_rds(dcl, file = here("data","washb_pair_level_summary_estimates.rds"))
write_csv(dcl, file = here("data","washb_pair_level_summary_estimates.csv"))


```

# Estimate 95% CIs for relative efficiency

Use a bootstrap resampling approach, resampling pairs with replacement, to estimate the 95% confidence interval for relative efficacy of geographic pair matching with 90 matched pairs. This will enable us to show whether lower efficacy at smaller sample sizes is significantly lower, and not just a function of sampling variability.

```{r bangladesh bootstrap CIs for relative efficiency}
#-------------------------------
# pivot wider to make the bootstrap
# easy
#-------------------------------
dboot <- dcl %>%
  filter(country == "Bangladesh") %>%
  group_by(outcome_lab)

# estimate outcome correlation, weighted by pair-wise N
corx <- function(x,y,w) {
    xw <- x*w
    yw <- y*w
    wcorr <- 2*cov(xw,yw) / ( var(xw) + var(yw) )
    return(wcorr)
}

#-------------------------------
# boostrap resample within
# each outcome group
# 1000 iterations
#-------------------------------
cor_boot_b <- foreach(iteri = 1:1000, .combine = rbind) %dopar% {
  set.seed(iteri)
  di <- dboot %>% 
    slice_sample(prop = 1, replace = TRUE)
  corest <- di %>% group_map( ~ corx(x=.x$Y1bar, y=.x$Y0bar,w = .x$w))
  
  res <- data.frame(iter = iteri, outcome_lab = levels(di$outcome_lab), corr = unlist(corest))
  res
}

cor_boot_b2 <- cor_boot_b %>%
  mutate(outcome_lab = factor(outcome_lab, levels = levels(dcl$outcome_lab)))

#-------------------------------
# calculate percentile 95% CIs 
# from the bootstrap distribution
#-------------------------------
cor_boot_ci_b <- cor_boot_b2 %>%
  group_by(outcome_lab) %>%
  mutate(cor_min95 = quantile(corr, probs = 0.025),
         cor_max95 = quantile(corr, probs = 0.975)) %>%
  slice(1) %>%
  select(outcome_lab, cor_min95, cor_max95)

#-------------------------------
# transform correlation 95% CIs 
# into relative efficacy
#-------------------------------
releff_ci_b <- cor_boot_ci_b %>%
  mutate(releff_min95 = 1/(1-cor_min95),
         releff_max95 = 1/(1-cor_max95)) %>%
  mutate(country = "Bangladesh")

#-------------------------------
# join to the existing estimates
# of relative efficiency
#-------------------------------
ate_res2 <- ate_res %>%
  left_join(releff_ci_b, by=c("country","outcome_lab"))

```

```{r kenya bootstrap CIs for relative efficiency}
#-------------------------------
# pivot wider to make the bootstrap
# easy
#-------------------------------
dboot <- dcl %>%
  filter(country == "Kenya") %>%
  mutate(outcome_lab = droplevels(outcome_lab)) %>%
  group_by(outcome_lab) 

#-------------------------------
# boostrap resample within
# each outcome group
# 1000 iterations
#-------------------------------
cor_boot_k <- foreach(iteri = 1:1000, .combine = rbind) %dopar% {
  set.seed(iteri)
  di <- dboot %>% 
    slice_sample(prop = 1, replace = TRUE)
  corest <- di %>% group_map( ~ corx(x=.x$Y1bar, y=.x$Y0bar,w = .x$w))
  
  res <- data.frame(iter = iteri, outcome_lab = levels(di$outcome_lab), corr = unlist(corest))
  res
}

cor_boot_k2 <- cor_boot_k %>%
  mutate(outcome_lab = factor(outcome_lab, levels = levels(dcl$outcome_lab)))

#-------------------------------
# calculate percentile 95% CIs 
# from the bootstrap distribution
#-------------------------------
cor_boot_ci_k <- cor_boot_k2 %>%
  group_by(outcome_lab) %>%
  mutate(cor_min95 = quantile(corr, probs = 0.025),
         cor_max95 = quantile(corr, probs = 0.975)) %>%
  slice(1) %>%
  select(outcome_lab, cor_min95, cor_max95)

#-------------------------------
# transform correlation 95% CIs 
# into relative efficacy
#-------------------------------
releff_ci_k <- cor_boot_ci_k %>%
  mutate(releff_min95 = 1/(1-cor_min95),
         releff_max95 = 1/(1-cor_max95)) %>%
  mutate(country = "Kenya")

#-------------------------------
# join to the existing estimates
# of relative efficiency
#-------------------------------
k_ate_res2 <- k_ate_res %>%
  left_join(releff_ci_k, by=c("country","outcome_lab"))

```


# Save ATE and Relative Efficiency Estimates
```{r save ate and reff estimates}
#-------------------------------
# Estimate control and intervention
# means
#-------------------------------
dcl_means <- dcl %>%
  group_by(country,outcome_lab) %>%
  summarize(Y0bar = weighted.mean(Y0bar,w = n0),
            Y1bar = weighted.mean(Y1bar,w = n1),
            .groups = "keep"
            )


ate_res3 <- ate_res2 %>%
  bind_rows(k_ate_res2) %>%
  left_join(dcl_means, by = c("country","outcome_lab")) %>%
  select(country, outcome_lab, Y0bar, Y1bar, everything())

write_rds(ate_res3, file = here("data","washb_ATE_releff_estimates.rds"))
write_csv(ate_res3, file = here("data","washb_ATE_releff_estimates.csv"))

```

# Relative Efficiency table

```{r summary relative efficacy table}
options(knitr.kable.NA = "‡")

sumtab <- ate_res %>%
  select(outcome_lab, bcorr_w = corr_w, beff_w = eff_w) %>%
  left_join(k_ate_res, by = "outcome_lab") %>%
  select(outcome_lab, bcorr_w, corr_w, beff_w, eff_w)


knitr::kable(sumtab,
             digits = c(0,2,2,1,1),
             align = c("lcccc"),
             col.names = c("Outcome","Bangladesh","Kenya","Bangladesh","Kenya"),
             caption = "Summary of pair-wise outcome correlation and relative efficacy of geographic pair-matching") %>%
  kable_styling(bootstrap_options = "striped") %>%
  pack_rows("Child growth",1,4) %>%
  pack_rows("Child development",5,9) %>%
  pack_rows("Infectious disease",10,14) %>%
  add_header_above(c(" " = 1, "Pair-wise correlation*" = 2, "Relative Efficiency†" = 2)) %>%
  footnote(symbol = c("Correlation between geographically paired, cluster-level means weighted by cluster sizes.",
                      "Relative efficiency of geographic pair-matching compared to an unmatched design, defined as 1/(1-r), where r is the correlation between paired outcomes. A relative efficiency of 2 means that a pair-matched study with 30 clusters per group has the same power as an unmatched study with 60 clusters per group.","Communicative Development Inventory (CDI) measures were not collected in the Kenya trial."))

```


# Relative Efficiency Figure

```{r plot relative efficiency, warning = FALSE}
# pivot the summary table longer to plot
dreffplot <- ate_res %>%
  select(country, outcome_lab, corr_u, eff_u, corr_w, eff_w) %>%
  bind_rows(k_ate_res %>% select(country, outcome_lab, corr_u, eff_u,  corr_w, eff_w))
# group outcomes for plot aesthetics
dreffplot$outcome_group = c(rep("Child growth",4),rep("Child development",5),rep("Infectious disease",5) , rep("Child growth",4),rep("Child development",3),rep("Infectious disease",5))
# make shorter outcome labels
dreffplot$outcome_lab2 = c( c("LAZ","WAZ","WHZ","HCZ","EASQ Communication","EASQ Gross motor","EASQ Personal-social","CDI Comprehension","CDI Expression","Diarrhea","Giardia sp.","Ascaris sp.","Trichuris sp.","Hookworm"), c("LAZ","WAZ","WHZ","HCZ","EASQ Communication","EASQ Gross motor","EASQ Personal-social","Diarrhea","Giardia sp.","Ascaris sp.","Trichuris sp.","Hookworm"))

dreffplot2 <- dreffplot %>%
  mutate(outcome_group = factor(outcome_group),
         country = factor(country)) %>%
  # tedious x and y nudge coordinates for labels to optimize display
  mutate(lab_xnudge = case_when(
           outcome_lab2 == "LAZ" & country == "Bangladesh" ~ 0.015,
           outcome_lab2 == "HCZ" & country == "Bangladesh" ~ 0.015,
           outcome_lab2 == "Diarrhea" & country == "Bangladesh" ~ 0.015,
           outcome_lab2 == "WHZ" & country == "Kenya" ~ 0.015,
           outcome_lab2 %in% c("EASQ Communication","EASQ Personal-social","CDI Expression") & country == "Bangladesh" ~ 0.015,
           TRUE ~ as.numeric(-0.015)
         ),
         lab_ynudge = case_when(
           outcome_lab2 == "Hookworm" & country == "Kenya" ~ 0.02,
           outcome_lab2 == "Trichuris sp." & country == "Kenya" ~ 0.02,
           outcome_lab2 == "WHZ" & country == "Kenya" ~ -0.02,
           outcome_lab2 == "EASQ Gross motor" & country == "Bangladesh" ~ 0.01,
           outcome_lab2 == "EASQ Personal-social" & country == "Bangladesh" ~ -0.02,
           outcome_lab2 == "EASQ Personal-social" & country == "Kenya" ~ 0.02,
           outcome_lab2 == "CDI Comprehension" & country == "Bangladesh" ~ 0.02,
           outcome_lab2 == "CDI Expression" & country == "Bangladesh" ~ -0.04,
           TRUE ~ as.numeric(0)
         ),
         lab_hjust = ifelse(lab_xnudge < 0 , 1, 0)
         )


# data frame for function
d_reff <- data.frame(rho = seq(0,1,by=0.01)) %>%
  mutate(reff = 1/(1-rho))

# make plot
pcols <- c("#D9B86A", "#9B9F7C", "#5986B0")
plot_reff <- ggplot(data=dreffplot2, aes(x = corr_w, y = eff_w)) +
  # facet over country
  facet_grid(~country) +
  # add function line
  geom_line(data=d_reff,aes(x=rho,y=reff),alpha = 0.4, linetype = "dashed", show.legend = FALSE) +
  # plot results
  # this offset is very idiosyncratic to optimize display -- fragile code!
  geom_text(aes(label = outcome_lab2, color = outcome_group), 
            hjust = dreffplot2$lab_hjust, 
            nudge_x = dreffplot2$lab_xnudge,
            nudge_y = dreffplot2$lab_ynudge,
            size = 2.5, show.legend = FALSE) +
  geom_point(aes(color = outcome_group), size = 2.2, alpha=1) + 
  geom_point(pch=21,bg=NA, size=2.2, show.legend = TRUE) +
  # refine aesthetics
  scale_color_manual(values = pcols, guide=guide_legend(title="Outcome group:")) +
  # scale_color_brewer(palette = "Dark2", guide=guide_legend(title="Outcome group:")) +
  # scale_color_viridis_d(begin = 0.4, end = 0.8, direction = -1, option = "E",  guide=guide_legend(title="Outcome group:")) +
  scale_y_continuous(breaks=seq(1,3.2,by=0.2))+
  scale_x_continuous(breaks=seq(0,0.7,by=0.1)) +
  coord_cartesian(ylim=c(1,3.2),xlim = c(0,0.7)) +
  labs(x=expression(paste("Correlation between paired outcomes, (",italic(r),")")),y=expression(paste("Relative efficiency of geographic pair-matching, (1-",italic(r),")")^-1), tag = "a") +
  theme_minimal() +
  theme(
    legend.position = "none",
    panel.grid.minor = element_blank(),
    plot.tag = element_text(face = "bold")
  )
plot_reff

```

# Break even correlation


The power of the matched t-test for a two-tailed 0.05 test where the power of the unmatched test is held at 0.80 and the pairs are uncorrelated

```{r power of matched vs unmatched}

#------------------------------
# power of the matched
# compared to unmatched test
# r = 0
#------------------------------
ns <- 2:50
sdu <- 1
powr0 <- foreach(ni = ns, .combine = rbind) %do% {
  pu <- power.t.test(n=ni,sd=sdu, power=0.8, type="two.sample")
  pm <- power.t.test(n=ni,delta=pu$delta, sd=sqrt(2)*sdu, sig.level= 0.05, type = "one.sample")
  res <- data.frame(n=ni, powm = pm$power, powu = pu$power,sdm=pm$sd,sdu = sdu)
}

ggplot(data=powr0, aes(x=n)) +
  geom_hline(yintercept = 0.8, color = "gray40") + 
  geom_line(aes(y=powm)) +
  scale_y_continuous(breaks=seq(0,1,by=0.1))+
  coord_cartesian(ylim = c(0,1)) +
  labs(x = "number of pairs", y = "power") +
  theme_minimal() 
```

Solve for break even correlations of matched versus unmatched designs. This is an adaptation of Figure 4 in Martin et al. (1993)(https://pubmed.ncbi.nlm.nih.gov/8456215/), where they present a function of within-pair correlation, $r_{xy}$, whose squared value equals the within-pair correlation, ($r_{yy}$ in their notation). Below is the break-even correlation for within-pair outcomes.

```{r break even correlation}
#------------------------------
# solve for break-even r
#------------------------------
ns <- 3:50
sdu <- 1
breakrs <- foreach(ni = ns, .combine = rbind) %do% {
  pu <- power.t.test(n=ni,sd=sdu, power=0.8, sig.level= 0.05, type="two.sample")
  pm <- power.t.test(n=ni,delta=pu$delta, power=0.8,sd=NULL, sig.level= 0.05, type = "one.sample")
  ri = 1 - ( pm$sd^2/(2*(sdu)^2) )
  res <- data.frame(n=ni, powm = pm$power, powu = pu$power,sdm=pm$sd,sdu = sdu, r=ri)
}
ggplot(data=breakrs, aes(x=n,y=r)) +
  geom_line(aes(), color = "gray40") + 
  geom_point() +
  scale_y_continuous(breaks=seq(0,1,by=0.1))+
  labs(x = "number of pairs", y = "break-even correlation (r)") +
  annotate("text",x = 10, y=0.225, label = "Favors a matched design", hjust = 0)+
  annotate("text",x = 1, y=0.025, label = "Favors unmatched design", hjust = 0)+
  coord_cartesian(ylim = c(0,0.6), xlim=c(0,50)) +
  theme_minimal() 

#------------------------------
# solve for break even r
# by iteration
# (not used) 100% consistent
# with the analytic solution, above
# just did this to confirm
#------------------------------
# ns <- 2:50
# sdu <- 1
# powrs <- foreach(ni = ns, .combine = rbind) %do% {
#   pu <- power.t.test(n=ni,sd=sdu, power=0.8, type="two.sample")
#   ri <- 0
#   powm <- 0
#   while(ri < 1 & powm < 0.8) {
#     pm <- power.t.test(n=ni,delta=pu$delta, sd=sqrt(2)*sdu*sqrt(1-ri), sig.level= 0.05, type = "one.sample")
#     powm <- pm$power
#     ri <- ri+0.001
#   }
#   res <- data.frame(n=ni, powm = pm$power, powu = pu$power,sdm=pm$sd,sdu = sdu, r=ri)
# }


```

# Correlation figure

Compare weighted versus unweighted correlation

```{r plot correlation}

# retrieve the break-even correlation for N = 10 pairs
breakr10 <- breakrs %>% 
  filter(n==10) %>%
  pull(r)

pcols <- c("#D9B86A", "#9B9F7C", "#5986B0")
plot_corr <- ggplot(data = dreffplot, aes(x = corr_w, y = corr_u)) +
  facet_grid(~country) +
  geom_vline(xintercept=breakr10,color = "gray60", lwd=0.5) + 
  annotate("text",x=breakr10+0.01,y=0.65,label="break-even correlation\nfor n=10 pairs",hjust=0,size=2.5) +
  geom_abline(intercept = 0, slope = 1, color="gray40") +
  
  geom_point(aes(color = outcome_group),size=2.5, alpha=0.9) +
  geom_point(pch=21, bg=NA, size=2.5, show.legend = TRUE) +
  geom_text(data = dreffplot %>% filter(corr_w - corr_u >0.2), 
            aes(label = outcome_lab2, color = outcome_group),
            size = 2.5, hjust=1, nudge_x = -0.02,show.legend = FALSE) +
  scale_color_manual(values = pcols, guide=guide_legend(title="Outcome group:")) +
  scale_fill_manual(values = pcols) +
  # scale_color_brewer(palette = "Dark2", guide=guide_legend(title="Outcome group:")) +
  scale_x_continuous(breaks=seq(0,1,by=0.1))+
  scale_y_continuous(breaks=seq(0,1,by=0.1))+
  labs(x = "Weighted correlation", y = "Unweighted correlation", tag="b ") +
  coord_cartesian(xlim=c(0,0.7),ylim = c(0,0.7)) +
  theme_minimal() +
  theme(
    legend.position = "bottom",
    panel.grid.minor = element_blank(),    
    plot.tag = element_text(face = "bold")

  )


plot_corr

```
Create a composite figure

```{r composite correlation figure, fig.height = 9}
plot_corr_comp <- grid.arrange(plot_reff,plot_corr,ncol=1,nrow=2)
ggsave(here("output","washb-geopair-reff-corr.png"),plot_corr_comp,device="png",height=9,width=7)
```


# Relative efficiency by prevalence figure

```{r plot relative efficiency by prevalence}

prevplotd <- ate_res3 %>%
  filter(outcome_lab %in% c("Diarrhea","Giardia sp.","Ascaris sp.","Trichuris sp.","Hookworm")) %>%
   mutate(
     lab_hjust = case_when(
       country == "Kenya" & outcome_lab %in% c("Hookworm","Trichuris sp.") ~ 0,
       TRUE ~ as.numeric(1)
         ),
     lab_xnudge = case_when(
       country == "Kenya" & outcome_lab %in% c("Hookworm","Trichuris sp.") ~ 0.01,
       TRUE ~ as.numeric(-0.01)
         ),
   )

plot_reff_by_prev <- ggplot( data = prevplotd, aes(x = Y0bar, y = eff_w)) +
  facet_grid(.~country) +
  geom_pointrange(aes(ymin = releff_min95, ymax = releff_max95), color = "gray40") +
  scale_x_continuous(breaks=seq(0,0.4,by=0.1), labels = sprintf("%1.0f",seq(0,0.4,by=0.1)*100))+
  labs(x = "Outcome prevalence in control clusters (%)", y = "Relative efficiency") +
   geom_text(aes(label = outcome_lab),
             hjust=prevplotd$lab_hjust, nudge_x = prevplotd$lab_xnudge,
            size = 2.5, show.legend = FALSE) +
  theme_minimal()

plot_reff_by_prev

ggsave(filename = here("output","washb-geopair-releff-by-prev.png"),plot_reff_by_prev,device = "png", height=4.5,width=7)
```

# Session Info
```{r session info}
sessionInfo()
```


