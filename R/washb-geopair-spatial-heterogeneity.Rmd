---
title: "Assessing outcome spatial heterogeneity in the WASH Benefits trials"
subtitle: " "
author: "Ben Arnold ben.arnold@ucsf.edu"
date: "updated: `r Sys.time()`"
output: 
  html_document:
    theme: default
    highlight: haddock
    code_folding: hide
    toc: true
    toc_depth: 3
    toc_float:
      collapsed: true
      smooth_scroll: true
---

# Summary

Summary here: **TBD**

Details of original citations and data sources here: **TBD**


# Preamble

```{r preamble}
library(here)
here()
#----------------------------
# source the config file
#----------------------------
source(here("R","washb-geopair-Config.R"))

#----------------------------
# add the raster package
# which conflicts with dplyr::select
#----------------------------
library(raster)

```



# Bangladesh

## Data prep

```{r load bangladesh data}
#-------------------------------
# load the formatted analysis
# data created by
# washb-geopair-data-processing.R
# washb-geopair-gps-data-processing.R
#-------------------------------

# anthropometry data
danth <- read_rds(here("data","bangl_analysis_anthro.rds")) %>%
  mutate(blockf = factor(block))

# child development data
dchdev <- read_rds(here("data","bangl_analysis_chdev.rds")) %>%
  mutate(blockf = factor(block))

# diarrhea data
ddiar <- read_rds(here("data","bangl_analysis_diar.rds")) %>%
  mutate(blockf = factor(block))

# parasite data
dpara <- read_rds(here("data","bangl_analysis_parasite.rds")) %>%
  mutate(blockf = factor(block))

# Cluster-level GPS locations (centroids of compounds in each cluster)
# NOT PUBLICLY AVAILABLE -- NEED TO USE ACCURATE LON/LAT FOR MAPPING
dgps <- read_rds(here("data","bangl_analysis_gps.rds")) %>%
  mutate(block = as.character(block),
         blockf = factor(block))
  # save control cluster points for convenience
  dbgps_control <- dgps %>%
    filter(tr=="Control")
  
ddists <- read_rds(here("data","bangl_analysis_block_dists.rds"))
```

```{r bangladesh cluster level means}
#-------------------------------
# read-in cluster level means
# these were estimated in the file
# washb-geopair-relative-efficiency.Rmd
#-------------------------------
dcl <- read_rds("~/washb-geopair/data/washb_pair_level_summary_estimates.rds")

```

```{r bangladesh make spatial data}
#-------------------------------
# Create 3 GPS datasetes for 
# the spatial kriging
#
# dataset 1 has all control
# cluster centroids, used for
# geostatistical model smooths
# of the control group outcomes (n=180)
#
# dataset 2 has all control and
# nutrition cluster centroids,
# used for geostatistical model smooths
# of the control + nutrition group
# outcomes in a joint model (n=360)
#
# dataset 3 has block
# level centroids, computed
# as the median lon/lat across
# clusters in each block (n=90)
#-------------------------------
dbgps_control <- dgps %>%
  filter(tr=="Control") %>%
  dplyr::select(clusterid,tr,block,blockf,lon,lat)

dbgps_cn <- dgps %>%
  filter(tr %in% c("Control","Nutrition","Nutrition + WSH")) %>%
  dplyr::select(clusterid,tr,block,blockf,lon,lat)

dbgps <- dgps %>%
  ungroup() %>%
  dplyr::select(block,blockf,tr,lon,lat) %>%
  group_by(block,blockf) %>%
  summarize(lon = median(lon),
            lat = median(lat), 
            .groups = "keep") %>%
  mutate(country = "Bangladesh") %>%
  left_join(dcl, by = c("country","block")) %>%
  # calculate the number positive in control clusters for binomial models
  mutate(pos0 = round(Y0bar*n0 ),
         pos0 = ifelse(outcome_lab %in% c("Diarrhea","Giardia sp.","Ascaris sp.","Trichuris sp.","Hookworm"), pos0, NA))

#-------------------------------
# create sf objects of gps datasets
#-------------------------------
dbgps_control_sf <- dbgps_control %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326) 

dbgps_cn_sf <- dbgps_cn %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326) 

dbgps_sf <- dbgps %>%
  st_as_sf(coords = c("lon", "lat"), crs = 4326) 


```



```{r make bangladesh prediction grid}
#---------------------------
# Identify the convex hull
# around all villages and make
# a polygon and prediction grid
#---------------------------
xycoords <- as.matrix(dgps[,c('lon','lat')])
xychull <- xycoords[chull(xycoords),]
bxypoly <- st_polygon(list(rbind(xychull,xychull[1,]))) %>%
  st_sfc() %>% st_sf() %>% st_set_crs(4326)

b_predgrid <- st_make_grid(bxypoly,
                           n=c(100,100),
                           what = "centers")

b_gridxy <- as.data.frame(st_coordinates(b_predgrid)) %>%
  rename(lon=X,lat=Y)

#---------------------------
# create a 6 km buffer around
# clusters
# 6 km was chosen through
# iteration, finding the
# smallest buffer around 
# clusters that would create a 
# single, contiguous
# prediction surface
#---------------------------

# get cluster centroids
dbgps_sf_utm <- dgps %>%
  ungroup() %>%
  st_as_sf(coords = c("lon", "lat"), crs=4326) %>%
  dplyr::select(geometry) %>%
  # transform to UTM for km units
  st_transform("+proj=utm +zone=46 +datum=WGS84 +units=km")


# identify a 6km buffer around each cluster
cl_6km <- st_buffer(dbgps_sf_utm, dist=6) %>%
  # identify their union, then convert to a single polygon
  summarise(geometry = st_union(geometry)) %>%
  st_cast("POLYGON") %>%
  # set the CRS back to WGS84
  st_transform(crs=4326) %>%
  # now crop the 6m buffer by the convex hull around study clusters
  # to only extrapolate within the point cloud (not beyond)
  st_intersection(bxypoly)

# create a grid of points around the 6km buffer polygon
b_6kmgrid <- st_make_grid(cl_6km,
                           n=c(100,100),
                           what = "centers") %>%
  st_sf() %>% st_set_crs(4326)

# subset the grid to those that intersect the polygon
# add lon/lat to the object for model predictions
b_6kmgridxy <- st_intersection(b_6kmgrid,cl_6km) 
b_6kmgridxy_coords <- st_coordinates(b_6kmgridxy)
b_6kmgridxy <- b_6kmgridxy %>%
  mutate(lon=as.double(b_6kmgridxy_coords[,1]),
         lat=as.double(b_6kmgridxy_coords[,2]))

```

## Semivariance


```{r bangladesh semivariance, eval = FALSE}

# rule of thumb: limit max distance in variogram to half of maximum interpoint distance
max_dist <- max(ddists) / 2 / 1000 # divide by 1000 to turn meters to km

bpairs_laz <- dbgps %>% filter(outcome_lab=="length-for-age z") %>% ungroup() 
bpairs_laz_sp <- SpatialPointsDataFrame(coords = bpairs_laz[,c("lon","lat")],bpairs_laz[,c("Y0bar")],match.ID=FALSE,proj4string = CRS("+proj=utm +zone=46N +datum=WGS84 +units=km"))

b_6kmgridxy_sp <- b_6kmgridxy %>%
  st_transform("+proj=utm +zone=46N +datum=WGS84 +units=km") %>%
  as_Spatial()

# note that automap creates fewer, but larger bins than gstat (gstat results were much more unstable)
# laz_variofit <- automap::autofitVariogram(formula = Y0bar~1,
#                                        input_data = bpairs_laz_sp,
#                                        model = "Mat", # ability to fit multiple models at once is deprecated?
#                                      miscFitOptions = list(merge.small.bins=TRUE)) # automap has this feature, gstat does not
# plot(laz_variofit)

# laz_kriged <- autoKrige(Y0bar~1, input_data=bpairs_laz_sp, new_data = b_6kmgridxy_sp)
# laz_kriged_sf <- st_as_sf(laz_kriged$krige_output)

# laz_variogram <- gstat::variogram(Y0bar~1, bpairs_laz_sp)
# laz_variofit  <- gstat::fit.variogram(laz_variogram, model = vgm(psill=1,model="Mat",range=max_dist,nugget=1))
# laz_kriged <- gstat::krige(formula = Y0bar~1, locations = bpairs_laz_sp, newdata = b_6kmgridxy_sp, model = laz_variofit)

# al_fit <- automap::autofitVariogram(formula = al~1,
#                                        input_data = dparas[!is.na(dparas$al),],
#                                        model = "Exp", # ability to fit multiple models at once is deprecated?
#                                      miscFitOptions = list(merge.small.bins=TRUE)) # automap has this feature, gstat does not

```

# Spatial predictions of outcomes and ATEs



```{r outcome kriging function}
## spatial prediction -----
# `get_grid_preds`: get predictions over a surface using a simple model
# input_grid: sf grid to get values over
# df: dataframe with coordinates ("lat" & "lon") and outcome variable to build model
# outcome_var: string, name of outcome variable of interest
get_grid_preds <- function(input_grid, model_fit){
  
  # convert grid into a data.frame with lon/lat variables
  newd <- input_grid %>%
    st_centroid() %>% 
    st_as_sf(crs = 4326) %>% 
    mutate(lon = sf::st_coordinates(.)[,1],
           lat = sf::st_coordinates(.)[,2]) %>%
    st_drop_geometry()
  
  # get predictions
  temp_preds <- predict(object = model_fit,
                        type = "response",
                        # create dataframe for predictions using centroid coordinates from grid
                        newdata = newd)
  
  # get estimated variance
  temp_predVar <- spaMM::get_predVar(object = model_fit, newdata = newd, which = "predVar")
  
  # merge predictions and variance with grid
  ret <- input_grid %>% 
    as.data.frame() %>% 
    st_as_sf(crs = 4326) %>% 
    mutate(pred = temp_preds,
          pred_var = temp_predVar)
  
  return(ret)
  
}


```

## LAZ

```{r bangladesh laz spatial model fit}
#-------------------------
# data frame for
# LAZ spatial modeling
#-------------------------
bcontrol_laz <- danth %>%
  filter(tr=="Control") %>%
  group_by(clusterid) %>%
  summarize(Y0bar=mean(laz,na.rm=TRUE),
            nobs=n()) %>%
  left_join(dgps,by=c("clusterid"))

bnutrition_laz <- danth %>%
  filter(tr %in% c("Nutrition","Nutrition + WSH")) %>%
  group_by(clusterid) %>%
  summarize(Y1bar=mean(laz,na.rm=TRUE),
            nobs=n()) %>%
  left_join(dgps,by=c("clusterid"))

bpairs_laz <- dbgps %>% filter(outcome_lab=="length-for-age z") %>% ungroup()



#-------------------------
# fit spatial models for
# control means
# treatment means
# differences
#-------------------------
# control mean
(b_fitlaz0 <- spaMM::fitme(Y0bar ~ 1 + Matern(1|lat + lon),
                           data = bcontrol_laz,
                           family = gaussian(link = "identity")) )

# nutrition mean
(b_fitlaz1 <- spaMM::fitme(Y1bar ~ 1 + Matern(1|lat + lon),
                           data = bnutrition_laz,
                           family = gaussian(link = "identity")) )

# mean difference
(b_fitlaz_diff <- spaMM::fitme(diff ~  1 + Matern(1|lat + lon),
                           data = bpairs_laz,
                           family = gaussian(link = "identity")) )

```

```{r bangladesh laz spatial model predictions}
#-------------------------
# get model predictions 
# over the study area grid
#-------------------------
b_lazpred0 <- get_grid_preds(input_grid = b_6kmgridxy, model_fit = b_fitlaz0) %>%
  rename(pred0=pred, pred0_var=pred_var)

b_lazpred1 <- get_grid_preds(input_grid = b_6kmgridxy, model_fit = b_fitlaz1) %>%
  rename(pred1=pred, pred1_var=pred_var) %>%
  st_drop_geometry()

b_lazpred_diff <- get_grid_preds(input_grid = b_6kmgridxy, model_fit = b_fitlaz_diff) %>%
  rename(pred_diff=pred, pred_var_diff = pred_var)

b_lazpred <- b_lazpred0 %>%
  as.data.frame() %>% 
  st_as_sf(crs = 4326) %>% 
  mutate(pred1 = b_lazpred1$pred1,
         pred1_var = b_lazpred1$pred1_var,
         diff = pred1-pred0)

```

```{r bangladesh laz spatial model predictions single model}
#-------------------------
# look at predictions from
# a joint model
#-------------------------

bcn_laz <- danth %>%
  filter(tr %in% c("Control","Nutrition","Nutrition + WSH")) %>%
  mutate(tx_c = ifelse(tr=="Control",TRUE,FALSE),
         tx_n = ifelse(tr=="Control",FALSE,TRUE),
         tx = ifelse(tr=="Control","Control","Nutrition"),
         tx = factor(tx),
         tx01 = ifelse(tr=="Control",0,1)) %>%
  group_by(clusterid,tx,tx01,tx_c,tx_n) %>%
  summarize(Ybar=mean(laz,na.rm=TRUE),
            nobs=n(), 
            .groups = "keep") %>%
  left_join(dgps,by=c("clusterid"))
  

# joint model of control and nutrition
(b_fitlaz01 <- spaMM::fitme(Ybar ~  1 + Matern(tx_c|lat + lon) + Matern(tx_n | lat + lon),
                           data = bcn_laz,
                           family = gaussian(link = "identity")) )
# (b_fitlaz01 <- spaMM::fitme(Ybar ~  tx + lat + lon + Matern(1| lat + lon),
#                            data = bcn_laz,
#                            family = gaussian(link = "identity")) )
# (b_fitlaz01 <- spaMM::fitme(Ybar ~  tx*(lat+lon),
#                            data = bcn_laz,
#                            family = gaussian(link = "identity")) )

```

```{r spatial diff krige prediction simulate posterior}
#--------------------------------------
# create prediction grid dataset  
#--------------------------------------
b_6kmgridxy_diff <- b_6kmgridxy %>%
  as_tibble()

#--------------------------------------
# parametric bootstrap simulations
# of the posterior outcome distribution
# at each point in the grid
#--------------------------------------
sims_diff <- simulate(b_fitlaz_diff, 
                 type = "predVar", 
                 nsim = 1000,
                 newdata = b_6kmgridxy_diff,
                 variances=list(linPred=TRUE,disp=TRUE)
                 )

sims_diff2 <- simulate(b_fitlaz_diff, 
                 type = "predVar", 
                 nsim = 1000,
                 # newdata = b_6kmgridxy_diff,
                 variances=list(linPred=TRUE,disp=TRUE)
                 )

#--------------------------------------
# mean and 
# 95% CI of the parametric
# bootstrap
#--------------------------------------
sims_diff_mu <- apply(sims_diff, 1, FUN = function(x) quantile(x, prob=c(0.5)))
sims_diff_ci <- apply(sims_diff, 1, FUN = function(x) quantile(x, prob=c(0.025,0.975)))

laz_diff_map <- b_6kmgridxy %>%
  mutate(fit = sims_diff_mu,
         fit_lb = sims_diff_ci[1,],
         fit_ub = sims_diff_ci[2,],
         fit_ci_width=fit_ub-fit_lb)

#--------------------------------------
# convert predicted surface of mean
# diff to a raster
#--------------------------------------
# pred_diff_raster <- rasterFromXYZ(xyz=data.frame(x = b_6kmgridxy_diff$lon,
#                                             y = b_6kmgridxy_diff$lat,
#                                             z = sims_diff_mu),
#                                   crs = 4326)
```


```{r spatial krige prediction simulate posterior}
#--------------------------------------
# create prediction grid datasets  
# for control and nutrition surfaces
#--------------------------------------
b_6kmgridxy_c <- b_6kmgridxy %>%
  mutate(tx = factor("Control"), tx01=0, tx_c = TRUE, tx_n = FALSE) %>%
  as_tibble()

b_6kmgridxy_n <- b_6kmgridxy %>%
  mutate(tx = factor("Nutrition"), tx01=1, tx_c = FALSE, tx_n = TRUE) %>%
  as_tibble()
 
#--------------------------------------
# parametric bootstrap simulations
# of the posterior outcome distribution
# at each point in the grid
# separate simulation for control and
# nutrition surfaces
# then, calculate the difference
#--------------------------------------
sims_c <- simulate(b_fitlaz0, 
                 type = "predVar", 
                 nsim = 1000,
                 newdata = b_6kmgridxy_c,
                 variances=list(linPred=TRUE,disp=TRUE)
                 )

sims_n <- simulate(b_fitlaz1, 
                 type = "predVar", 
                 nsim = 1000,
                 newdata = b_6kmgridxy_n,
                 variances=list(linPred=TRUE,disp=TRUE)
                 )

sims_diffnc <- sims_n - sims_c

#--------------------------------------
# mean and 
# 95% CI of the parametric
# bootstrap
#--------------------------------------
sims_diffnc_mu <- apply(sims_diffnc, 1, FUN = function(x) quantile(x, prob=c(0.5)))
sims_diffnc_ci <- apply(sims_diffnc, 1, FUN = function(x) quantile(x, prob=c(0.025,0.975)))

laz_diffnc_map <- b_6kmgridxy %>%
  mutate(fit = sims_diffnc_mu,
         fit_lb = sims_diffnc_ci[1,],
         fit_ub = sims_diffnc_ci[2,],
         fit_ci_width=fit_ub-fit_lb)

#--------------------------------------
# diagnostics only: predictions at
# sampling locations
#--------------------------------------
sims_cp <- simulate(b_fitlaz01, 
                 type = "predVar", 
                 nsim = 1000,
                 newdata= bcn_laz %>% mutate(tx01=0, tr_c=TRUE,tr_n=FALSE),
                 variances=list(linPred=TRUE,disp=TRUE)
                 )

sims_np <- simulate(b_fitlaz01, 
                 type = "predVar",
                 nsim = 1000,
                 newdata= bcn_laz %>% mutate(tx01=1, tr_c=FALSE,tr_n=TRUE),
                 variances=list(linPred=TRUE,disp=FALSE)
                 )

```


```{r spatial krige prediction original }
b_6kmgridxy_c <- b_6kmgridxy %>%
  mutate(tx = factor("Control"), tx01=0, tx_c = TRUE, tx_n = FALSE)
b_6kmgridxy_n <- b_6kmgridxy %>%
  mutate(tx = factor("Nutrition"), tx01=1, tx_c = FALSE, tx_n = TRUE)

b_lazpred0 <- get_grid_preds(input_grid = b_6kmgridxy_c, model_fit = b_fitlaz01) %>%
  rename(pred0=pred, pred0_var=pred_var)

b_lazpred1 <- get_grid_preds(input_grid = b_6kmgridxy_n, model_fit = b_fitlaz01) %>%
  rename(pred1=pred, pred1_var=pred_var)

b_lazpred <- b_lazpred0 %>%
  as.data.frame() %>% 
  st_as_sf(crs = 4326) %>% 
  mutate(pred1 = b_lazpred1$pred1,
         pred1_var = b_lazpred1$pred1_var,
         diff = pred1-pred0)

```

```{r bangladesh laz spatial model predictions spline model, eval=FALSE}
# try with a 3-dimensional spline
# (b_fitlaz01 <- mgcv::gam(Ybar ~ tx + lat + lon + s(tx01,lat,lon, k=-1,bs="gp"), 
#                    family="gaussian", weights = nobs,
#                    data=bcn_laz,
#                    method="REML", select=TRUE) )
# 
# 
# b_lazpred0 <- get_grid_preds(input_grid = b_6kmgridxy_c, model_fit = b_fitlaz01) %>%
#   rename(pred0=pred)
# 
# b_lazpred1 <- get_grid_preds(input_grid = b_6kmgridxy_n, model_fit = b_fitlaz01) %>%
#   rename(pred1=pred)
# 
# b_lazpred <- b_lazpred0 %>%
#   as.data.frame() %>% 
#   st_as_sf(crs = 4326) %>% 
#   mutate(pred1 = b_lazpred1$pred1,
#          pred1_var = b_lazpred1$pred1_var,
#          diff = pred1-pred0)


```


```{r map laz control}

map_laz0 <- ggplot(data=b_lazpred) + 
  geom_sf(aes(color=pred0)) + 
  coord_sf(crs = 4326) +
  scale_color_viridis(option="mako", begin=0.1, limits = c(-2.1,-1.0), breaks=seq(-2.0,-1.0,by=0.5),
                      guide=guide_colorbar(title="LAZ in control", 
                                           title.position = "left",
                                           title.vjust = 1,
                                           direction="horizontal",
                                           label.position = "bottom",
                                           barheight=unit(10,"pt"))) +
  # scale_color_gradient(low=cbpal[8], high="white", limits = c(-2.5,-1), guide=guide_colorbar(title="LAZ")) +
  geom_point(data=dbgps_cn %>% filter(tr=="Control"), aes(x=lon,y=lat),pch=20,size=0.2,color="black") +
  # geom_point(data=dgps, aes(x=lon,y=lat),pch=20,size=0.1,color="black") +
  labs(x="Latitude",y="Longitude",tag="a") +
  annotation_scale(location = "bl", width_hint = 0.3) +
  annotation_north_arrow(location = "bl", which_north = "true", 
        pad_x = unit(0.05, "in"), pad_y = unit(0.25, "in"),
        height=unit(0.75,"cm"), width=unit(0.75,"cm"),
        style = north_arrow_fancy_orienteering
        ) +
  theme_bw() +
  theme(
    legend.position = "bottom",
    plot.tag = element_text(face="bold")
  )
```


```{r map laz nutrition}

map_laz1 <- ggplot(data=b_lazpred) + 
  geom_sf(aes(color=pred1)) + 
  coord_sf(crs = 4326) +
  scale_color_viridis(option="mako", begin=0.1, limits = c(-2.1,-1.0), breaks=seq(-2.0,-1.0,by=0.5),
                      guide=guide_colorbar(title="LAZ in nutrition", 
                                           title.position = "left",
                                           title.vjust = 1,
                                           direction="horizontal",
                                           label.position = "bottom",
                                           barheight=unit(10,"pt"))) +
  # scale_color_gradient(low=cbpal[8], high="white", limits = c(-2.5,-1), guide=guide_colorbar(title="LAZ")) +
  geom_point(data=dbgps_cn %>% filter(tr!="Control"), aes(x=lon,y=lat),pch=20,size=0.2,color="black") +
  # geom_point(data=dgps, aes(x=lon,y=lat),pch=20,size=0.1,color="black") +
  labs(x="Latitude",y="Longitude",tag="b") +
  annotation_scale(location = "bl", width_hint = 0.3) +
  annotation_north_arrow(location = "bl", which_north = "true", 
        pad_x = unit(0.05, "in"), pad_y = unit(0.25, "in"),
        height=unit(0.75,"cm"), width=unit(0.75,"cm"),
        style = north_arrow_fancy_orienteering
        ) +
  theme_bw() +
  theme(
    legend.position = "bottom",
    plot.tag = element_text(face="bold")
  )

```

```{r map laz predicted ATE}


map_laz_ate <- ggplot(data=b_lazpred) + 
  geom_sf(aes(color=diff)) + 
  scale_color_gradient2(low=cbpal[2], mid="white", high=cbpal[3], limits = c(-0.2,0.4),
                        breaks = seq(-0.2,0.4,by=0.2),
                        guide=guide_colorbar(title="Difference in LAZ", 
                                           title.position = "left",
                                           title.vjust = 1,
                                           direction="horizontal",
                                           label.position = "bottom",
                                           barheight=unit(10,"pt"),
                                           ticks.colour = "black",
                                           ticks.linewidth = 1,
                                           frame.colour = "black"
                        )) +
  geom_point(data=dbgps_cn, aes(x=lon,y=lat),pch=20,size=0.2,color="black") +
  labs(x="Latitude",y="Longitude",tag="c") +
  annotation_scale(location = "bl", width_hint = 0.3) +
  annotation_north_arrow(location = "bl", which_north = "true", 
        pad_x = unit(0.05, "in"), pad_y = unit(0.25, "in"),
        height=unit(0.75,"cm"), width=unit(0.75,"cm"),
        style = north_arrow_fancy_orienteering
        ) +
  theme_bw() +
  theme(
    legend.position = "bottom",
    plot.tag = element_text(face="bold")
  )

```

```{r laz composite map, fig.width=8}
laz_map_composite <- grid.arrange(map_laz0,map_laz1,map_laz_ate,nrow=1,ncol=3)
ggsave(filename=here("output","washb-geopair-bangladesh-laz-map.png"),plot = laz_map_composite,device="png",width=15,height=6)
```


```{r map laz predicted ATE from pairs}

# map_laz_diff <- ggplot(data=b_lazpred_diff) + 
# map_laz_diff <- ggplot(data=laz_diff_map) + 
map_laz_diff <- ggplot(data=laz_diffnc_map) + 
  geom_sf(aes(color=fit_lb)) + 
  coord_sf(crs = 4326) +
  scale_color_gradient2(low=cbpal[2], mid="white", high=cbpal[3],limits = c(-0.4,0.42),
                        breaks = seq(-0.4,0.4,by=0.2),
                        guide=guide_colorbar(title="Difference in LAZ",
                                           title.position = "left",
                                           title.vjust = 1,
                                           direction="horizontal",
                                           label.position = "bottom",
                                           barheight=unit(10,"pt"),
                                           ticks.colour = "black",
                                           ticks.linewidth = 1,
                                           frame.colour = "black"
                        )
                        ) +
  geom_point(data=dbgps_cn, aes(x=lon,y=lat),pch=20,size=0.1,color="black") +
  labs(x="Latitude",y="Longitude",tag="d") +
  annotation_scale(location = "bl", width_hint = 0.3) +
  annotation_north_arrow(location = "bl", which_north = "true", 
        pad_x = unit(0.05, "in"), pad_y = unit(0.25, "in"),
        height=unit(0.75,"cm"), width=unit(0.75,"cm"),
        style = north_arrow_fancy_orienteering
        ) +
  theme_bw() +
  theme(
    legend.position = "bottom",
    plot.tag = element_text(face="bold")
  )

```



```{r laz composite map with diffs, fig.width=8}
laz_map_composite <- grid.arrange(map_laz0,map_laz1,map_laz_ate,map_laz_diff, nrow=1,ncol=4)
ggsave(filename=here("output","washb-geopair-bangladesh-laz-map-with-diff.png"),plot = laz_map_composite,device="png",width=20,height=6)
```


```{r bangladesh geospatial model fits}
#---------------------------
# geospatial model predictions
# low rank gaussian process
# to smooth between points
#---------------------------
library(mgcv)

# LAZ
geofit_laz <- gam(Y0bar ~ s(lat,lon, k=-1,bs="gp"), 
                   family="gaussian", weights = n0,
                   data=dbgps %>% filter(outcome_lab == "length-for-age z"),
                   method="REML", select=TRUE)

# CDI comprehension
geofit_cdic <- gam(Y0bar ~ s(lat,lon, k=-1,bs="gp"), 
                   family="gaussian", weights = n0,
                   data=dbgps %>% filter(outcome_lab == "CDI comprehension z"),
                   method="REML", select=TRUE)

# Ascaris
geofit_al <- gam(cbind(pos0,n0) ~ s(lat,lon, k=-1,bs="gp"), 
                   family="binomial",
                   data=dbgps %>% filter(outcome_lab == "Ascaris sp."),
                   method="REML",
                   select=TRUE)

```

```{r bangladesh geospatial model predictions}
#---------------------------
# model predictions 
# at village points
#---------------------------
dbgps$pred <- NA
dbgps$pred[dbgps$outcome_lab == "length-for-age z"] <- predict(geofit_laz,type="response")
dbgps$pred[dbgps$outcome_lab == "CDI comprehension z"] <- predict(geofit_cdic,type="response")
dbgps$pred[dbgps$outcome_lab == "Ascaris sp."] <- predict(geofit_al,type="response")


#---------------------------
# model predictions over 
# the entire prediction grid
#---------------------------
bpred_laz <- predict(geofit_laz,newdata=b_gridxy,type="response")
bpred_cdic <- predict(geofit_cdic,newdata=b_gridxy,type="response")
bpred_al <- predict(geofit_al,newdata=b_gridxy,type="response")

# as rasters
brast_laz <- SpatialPixelsDataFrame(points=b_gridxy[c("lon","lat")],data=data.frame(fit=bpred_laz),proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))

brast_cdic <- SpatialPixelsDataFrame(points=b_gridxy[c("lon","lat")],data=data.frame(fit=bpred_cdic),proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))

brast_al <- SpatialPixelsDataFrame(points=b_gridxy[c("lon","lat")],data=data.frame(fit=bpred_al*100),proj4string=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs"))

```


# Bangladesh Maps

## LAZ

```{r map Bangladesh LAZ, warning = FALSE, out.width = "100%"}

brastp_laz <- raster::raster(brast_laz,layer=1)
xlon <- median(dbgps_control$lon)
ylat <- median(dbgps_control$lat)

# define the color palettes for mean 
# reverse palettes are there just for the legend
# so that we can present high values on the top
pal <- colorNumeric(
  palette = "viridis",
  domain=c(raster::values(brastp_laz)),
  na.color = "transparent"
)
pal_rev <- colorNumeric(
  palette = "viridis",
  domain=c(raster::values(brastp_laz)),
  na.color = "transparent",
  reverse = TRUE
)

# make the map
mapb_laz <- leaflet(width = "100%") %>% 
  addProviderTiles("CartoDB.Positron",options=providerTileOptions(opacity=1)) %>%
  setView(lng = xlon, lat = ylat, zoom = 8) %>%
  addRasterImage(brastp_laz, colors=pal, opacity=0.9, group="Mean") %>%
  addCircleMarkers(data = dbgps_control,
                   lng = ~ lon, lat = ~ lat,
                   radius = 1,
                   color = ~"black", fill = ~ "black",  weight=1,fillOpacity = 1
              ) %>%
  
  # add scale bar and legends
  addScaleBar(position="bottomleft",options=scaleBarOptions(imperial = FALSE)) %>%
  addLegend(position="bottomright",
            pal = pal_rev, 
            values= c(raster::values(brastp_laz)),
            labFormat = labelFormat(transform = function(x) sort(x, decreasing = TRUE)),
            title = "LAZ",
            group = "Mean"
            )

mapb_laz

```


## CDI comprehension

Communicative Development Inventory (comprehension)

```{r map Bangladesh CDI comp, warning = FALSE, out.width = "100%"}

brastp_cdic <- raster::raster(brast_cdic,layer=1)
xlon <- median(dbgps_control$lon)
ylat <- median(dbgps_control$lat)

# define the color palettes for mean 
# reverse palettes are there just for the legend
# so that we can present high values on the top
scale_range <- c(-0.2, 0.2)
rcartopal <- carto_pal(9,"Earth")
pal <- colorNumeric(
  palette = rcartopal,
  domain= scale_range,
  na.color = "transparent"
)
pal_rev <- colorNumeric(
  palette = rcartopal,
  domain=scale_range,
  na.color = "transparent",
  reverse = TRUE
)

# make the map
mapb_cdic <- leaflet(width = "100%") %>% 
  addProviderTiles("CartoDB.Positron",options=providerTileOptions(opacity=1)) %>%
  setView(lng = xlon, lat = ylat, zoom = 8) %>%
  addRasterImage(brastp_cdic, colors=pal, opacity=1, group="Mean") %>%
  addCircleMarkers(data = dbgps_control,
                   lng = ~ lon, lat = ~ lat,
                   radius = 1,
                   color = ~"black", fill = ~ "black",  weight=1,fillOpacity = 1
              ) %>%
  
  # add scale bar and legends
  addScaleBar(position="bottomleft",options=scaleBarOptions(imperial = FALSE)) %>%
  addLegend(position="bottomright",
            pal = pal_rev, 
            values= scale_range,
            labFormat = labelFormat(transform = function(x) sort(x, decreasing = TRUE)),
            title = "CDI Z-score<br>comprehension",
            group = "Mean"
            )

mapb_cdic


```


## Ascaris sp.

```{r map Bangladesh Ascaris, warning = FALSE, out.width = "100%"}

brastp_al <- raster::raster(brast_al,layer=1)
xlon <- median(dbgps_control$lon)
ylat <- median(dbgps_control$lat)

# define the color palettes for mean 
# reverse palettes are there just for the legend
# so that we can present high values on the top
pal <- colorNumeric(
  palette = "inferno",
  domain=c(raster::values(brastp_al)),
  na.color = "transparent"
)
pal_rev <- colorNumeric(
  palette = "inferno",
  domain=c(raster::values(brastp_al)),
  na.color = "transparent",
  reverse = TRUE
)

# make the map
mapb_al <- leaflet(width = "100%") %>% 
  addProviderTiles("CartoDB.Positron",options=providerTileOptions(opacity=1)) %>%
  setView(lng = xlon, lat = ylat, zoom = 8) %>%
  addRasterImage(brastp_al, colors=pal, opacity=0.9, group="Prevalence") %>%
  addCircleMarkers(data = dbgps_control,
                   lng = ~ lon, lat = ~ lat,
                   radius = 1,
                   color = ~"black", fill = ~ "black",  weight=1,fillOpacity = 1
              ) %>%
  
  # add scale bar and legends
  addScaleBar(position="bottomleft",options=scaleBarOptions(imperial = FALSE)) %>%
  addLegend(position="bottomright",
            pal = pal_rev, 
            values= c(raster::values(brastp_al)),
            labFormat = labelFormat(transform = function(x) sort(x, decreasing = TRUE)),
            title = "Ascaris<br>Prevalence (%)",
            group = "Prevalence"
            )

mapb_al

```



# Session Info
```{r session info}

#----------------------------
# detach the raster package
#----------------------------
detach("package:raster", unload=TRUE)

sessionInfo()
```


